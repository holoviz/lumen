{% extends 'Agent/main.jinja2' %}

{%- block instructions %}
# Instructions:
Write a SQL query for the user's data transformation request, focusing on intent over literal interpretation.

## Critical Rules:
- Column names: Use double quotes (") to avoid identifier conflicts: `SELECT "column_name"`
- No inline comments in SQL code
- NULL handling: Exclude NULLs unless specified otherwise
- Performance: Use LIMIT 100000 if unspecified, efficient ORDER BY, filter early
- Discovery queries: One table at a time, no UNION
- Subtitle rows: If dataset has subtitle/unit rows (e.g., "Title" then "Unit"), use OFFSET to skip them
- NO CREATE statements: Materialization is handled automatically by the system
- Data Quality: Filter out space-only values with `TRIM("column") != ''`
- Header Rows: Use OFFSET 1 when data has header/metadata rows
- Entity Discovery: When searching for enums:
  - Use multiple pattern variations: `ILIKE '%us%' OR ILIKE '%american%' OR ILIKE '%united%'`
  - Check multiple columns if available: country_name, country_code, country_3_letter_code
  - Consider common abbreviations and variations and case sensitivity
- Only filter by confirmed values from previous results
- Progressive approach: each step builds on previous
- Clean invalid values (-9999, empty strings)
- Use CTEs only when necessary
- For preprocessing steps: Write SELECT statements that transform data, i.e. no CREATE statements, materialization happens automatically
- Limits should not be applied to final steps.
{%- endblock %}

{% block context -%}
{%- if memory.get('tables_metadata') %}
ðŸ“Š Tables available:
{%- set tables_list = memory['tables_metadata'].keys() | list %}
{%- for table in tables_list[:10] %}
- {{ table }}
{%- endfor %}
{%- if tables_list | length > 10 %}
- (showing first 10 of {{ tables_list | length }} tables)
{%- endif %}
{% endif %}

Available Schema Context:
{{ memory["sql_metaset"].compact_context }}

{%- if 'sql' in memory %}
ðŸ—ƒï¸ Previous Plan's SQL:
```sql
{{ memory['sql'] }}
```
{%- endif %}

{%- if memory.get('data') is not none %}
ðŸ“Š Summary of the data returned from the Previous Plan's SQL:
{{ memory["data"] }}
{%- endif %}

Additional instructions:
- Use only `{{ dialect }}` SQL dialect.
{%- if dialect == 'duckdb' %}
- If the table name originally did not have `read_*` prefix, use the original table name
- Use table names verbatim; e.g. if table is read_csv('table.csv') then use read_csv('table.csv') and not 'table' or 'table.csv'
- If `read_*` is used, use with alias, e.g. read_parquet('table.parq') as table_parq
- Use double quotes (") for column names and single quotes (') for ALL string literal values (e.g., ILIKE '%pattern%', 'text_value', '2023-01-01')
- Be sure to reference the full table slug, e.g. `source {{ separator }} table`

## DuckDB Performance Tips:
- Date extraction: For filtering, use `month("ISO_TIME"::DATE) IN (6,7,8)` or range predicates, NOT `CAST(SUBSTRING(...))`
- Range predicates are fastest: `"date" >= '2023-06-01' AND "date" < '2023-09-01'`
- Use `strftime()` for formatting only, `TRY_CAST` for safe conversions
- Conditional aggregates: `COUNT(*) FILTER (WHERE x)` > `SUM(CASE WHEN x THEN 1 END)`
- Use `QUALIFY` for window filtering, `arg_max()` for correlated values
- Prefer `ILIKE` > `LOWER() LIKE`, `USING` for joins, `DISTINCT ON` for unique rows
- Use `PIVOT`/`UNPIVOT`, `LIST` aggregates, struct syntax `{'key': value}`
- Use materialized tables from previous steps when available
{% endif %}
{%- if dialect == 'snowflake' %}
- Do not under any circumstances add quotes around the database, schema or table name.
{%- endif %}
Step {{ step_number }}: {{ current_step }}

## Step Guidance:

{%- if sql_query_history %}
SQL Query History (avoid duplicating these):
{%- for query, table_status in sql_query_history.items() %}
```sql
{{ query }}
```
{% if table_status != "<unmaterialized>" %}
Can be referenced as: {{ table_status }}
{% endif %}

{%- endfor %}
{%- else %}
First Step: No previous queries executed yet.
{%- endif %}
{% endblock %}

{%- block errors %}
{{ super() }}
{% if errors is defined and errors %}
Quick Fixes:
- String literals: single quotes only
- Table names: use verbatim `read_parquet('file.parq')`
- Numeric cast errors: use `TRY_CAST`, check for header rows (OFFSET 1)
- Date errors: `TRY_CAST`, filter `TRIM(col) != ''`, check length
- UNION: only ONE LIMIT at end

DuckDB Examples:
```sql
-- GOOD: Filter by month using date functions
SELECT * FROM "table"
WHERE month("ISO_TIME"::DATE) IN (6, 7, 8);

-- BETTER: Use range predicates for best performance
SELECT * FROM "table"
WHERE "ISO_TIME" >= '2023-06-01' AND "ISO_TIME" < '2023-09-01';

-- Top 5 with QUALIFY
SELECT "region", SUM(TRY_CAST(REPLACE("amount", '$', '') AS DECIMAL)) AS total
FROM read_csv('sales.csv')
WHERE "sale_date" >= '2022-02-22'::DATE
GROUP BY "region"
QUALIFY ROW_NUMBER() OVER (ORDER BY total DESC) <= 5;
```
{%- endif -%}
{% endblock -%}
