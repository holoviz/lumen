{% extends 'Agent/main.jinja2' %}

{%- block instructions %}
# Instructions:
Write a SQL query for the user's data transformation request, focusing on intent over literal interpretation.

## Critical Rules:
- Column names: Use double quotes (") to avoid identifier conflicts: `SELECT "column_name"`
- No inline comments in SQL code
- NULL handling: Exclude NULLs unless specified otherwise
- Performance: Use LIMIT 100000 if unspecified, efficient ORDER BY, filter early
- Discovery queries: One table at a time, no UNION
- Subtitle rows: If dataset has subtitle/unit rows (e.g., "Title" then "Unit"), use OFFSET to skip them
- NO CREATE statements: Materialization is handled automatically by the system
- Data Quality: Filter out space-only values with `TRIM("column") != ''`
- Header Rows: Use OFFSET 1 when data has header/metadata rows
- Entity Discovery: When searching for enums:
  - Use multiple pattern variations: `ILIKE '%us%' OR ILIKE '%american%' OR ILIKE '%united%'`
  - Check multiple columns if available: country_name, country_code, country_3_letter_code
  - Consider common abbreviations and variations and case sensitivity
- Only filter by confirmed values from previous results
- Progressive approach: each step builds on previous
- Clean invalid values (-9999, empty strings)
- Use CTEs only when necessary
- For preprocessing steps: Write SELECT statements that transform data, i.e. no CREATE statements, materialization happens automatically
- Limits should not be applied to final steps.
{%- endblock %}

{% block context -%}
Available Schema:
{{ memory["sql_metaset"].compact_context }}

{%- if 'sql' in memory %}
ðŸ—ƒï¸ Previous Plan's SQL:
```sql
{{ memory['sql'] }}
```
{%- endif %}

{%- if memory.get('data') is not none %}
ðŸ“Š Summary of the data returned from the Previous Plan's SQL:
{{ memory["data"] }}
{%- endif %}

Additional instructions:
- Use only `{{ dialect }}` SQL dialect.
{%- if dialect == 'duckdb' %}
- If the table name originally did not have `read_*` prefix, use the original table name
- Use table names verbatim; e.g. if table is read_csv('table.csv') then use read_csv('table.csv') and not 'table' or 'table.csv'
- If `read_*` is used, use with alias, e.g. read_parquet('table.parq') as table_parq
- Use double quotes (") for column names and single quotes (') for ALL string literal values (e.g., ILIKE '%pattern%', 'text_value', '2023-01-01')
- Be sure to reference the full table slug, e.g. `source {{ separator }} table`
- Use CAST('YYYY-MM-DD' AS DATE) for static date literals.
- Use MAKE_DATE(year, month, day) to construct dates from numeric components.
- Use CAST(year || '-' || month || '-' || day AS DATE) for basic string concatenation of date parts, when format is guaranteed to be 'YYYY-MM-DD'.
- Use STRPTIME(string, format) to parse dates from custom or non-standard string formats (e.g., '01/12/2020' with format '%d/%m/%Y').
- If avaialble, use materialized tables from previous steps
{% endif %}
{%- if dialect == 'snowflake' %}
- Do not under any circumstances add quotes around the database, schema or table name.
{%- endif %}
Step {{ step_number }}: {{ current_step }}

## Step Guidance:

{%- if sql_query_history %}
SQL Query History (avoid duplicating these):
{%- for query, table_status in sql_query_history.items() %}
```sql
{{ query }}
```
Table Status: {{ table_status }}

{%- endfor %}
{%- else %}
First Step: No previous queries executed yet.
{%- endif %}
{% endblock %}

{%- block errors %}
{{ super() }}
{% if errors is defined and errors %}
Error Fixes:
- Quote string literals with single quotes
- Use table names verbatim: `read_parquet('file.parq')`
- No inline comments
- Handle NULLs with COALESCE/IS NULL
- Clean numeric values, use TRY_CAST for safety
- If cannot cast string, it might be due to the second row being a subtitle/unit row, so use OFFSET to skip it
- Use TRY_CAST for numeric conversions to avoid errors
- Only ONE limit clause is allowed, even when using UNION
- For date conversion errors: Check for header rows (use OFFSET 1), filter spaces with `TRIM(column) != ''`, ensure minimum length
- For invalid date formats: Use `TRY_CAST` instead of `CAST` for date conversions

Date Construction Examples:
```sql
-- Constructing dates from year, month, day
SELECT MAKE_DATE(2023, 12, 1) AS start_date;

-- From string concatenation
SELECT CAST("year" || '-12-01' AS DATE) AS start_date;

-- Season to date mapping
CASE "season"
WHEN 'DJF' THEN MAKE_DATE("year" - 1, 12, 1)
WHEN 'JFM' THEN MAKE_DATE("year", 1, 1)
WHEN 'FMA' THEN MAKE_DATE("year", 2, 1)
ELSE NULL
END AS "season_start"

-- Clean timestamp extraction (for ISO_TIME issues)
SELECT *,
    TRY_CAST(SUBSTRING("ISO_TIME", 1, 10) AS DATE) AS "date_key"
FROM "table" OFFSET 1
WHERE "ISO_TIME" IS NOT NULL
    AND TRIM("ISO_TIME") != ''
    AND LENGTH(TRIM("ISO_TIME")) >= 19
    AND "ISO_TIME" NOT LIKE '%Year%'
    AND "ISO_TIME" NOT LIKE '%degrees%'
LIMIT 100000;
```

-- Data cleaning with header skip and space filtering
SELECT *,
  CAST(SUBSTRING("ISO_TIME", 1, 10) AS DATE) AS "date_key"
FROM "table" OFFSET 1
WHERE "ISO_TIME" IS NOT NULL
  AND TRIM("ISO_TIME") != ''
  AND LENGTH(TRIM("ISO_TIME")) >= 10
LIMIT 100000;

-- UNION (LIMIT only at end)
SELECT "season" AS "value" FROM "table" WHERE "season" IS NOT NULL
UNION ALL
SELECT SUBSTR("date", 1, 4) AS "value" FROM "table" WHERE "date" IS NOT NULL
LIMIT 10;
```

Multiple DISTINCT columns (WRONG vs RIGHT):
```sql
-- WRONG: Cannot use multiple DISTINCT in same SELECT
SELECT DISTINCT "ISO_TIME", DISTINCT "SEASON" FROM "table";

-- RIGHT: Use separate queries with UNION ALL
SELECT DISTINCT "ISO_TIME" AS "value", 'ISO_TIME' AS "column_name"
FROM "table"
WHERE "ISO_TIME" IS NOT NULL
  AND TRIM("ISO_TIME") != ''
  AND LENGTH(TRIM("ISO_TIME")) >= 10
UNION ALL
SELECT DISTINCT "SEASON" AS "value", 'SEASON' AS "column_name"
FROM "table"
WHERE "SEASON" IS NOT NULL
  AND TRIM("SEASON") != ''
ORDER BY "column_name", "value"
LIMIT 100;
```

If the query is "Which five regions have the highest total sales from 2022-02-22?"...

- GOOD:
```sql
WITH sales_summary AS (
    SELECT
        "region",
        SUM(
            TRY_CAST(
                REPLACE(
                    REPLACE("amount", '$', ''),
                    ',', ''
                ) AS DECIMAL(10,2)
            )
        ) AS total_sales
    FROM read_csv('sales.csv')
    WHERE "sale_date" >= DATE '2022-02-22'
      AND TRY_CAST(REPLACE(REPLACE("amount", '$', ''), ',', '') AS DECIMAL(10,2)) IS NOT NULL
      AND "region" IS NOT NULL
    GROUP BY "region"
)
SELECT
    "region",
    total_sales
FROM sales_summary
WHERE total_sales > 0
ORDER BY total_sales DESC
LIMIT 100000;
```
{%- endif -%}
{% endblock -%}
