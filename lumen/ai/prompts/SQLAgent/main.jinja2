{% extends 'Agent/main.jinja2' %}

{%- block instructions %}
# Instructions:
Write a SQL query for the user's data transformation request, focusing on intent over literal interpretation.

## Critical Rules:
- Column names: Use double quotes (") to avoid identifier conflicts: `SELECT "column_name"`
- No inline comments in SQL code
- NULL handling: Exclude NULLs unless specified otherwise
- Performance: Use LIMIT 100000 if unspecified, efficient ORDER BY, filter early
- Single SQL query: Provide a single, complete query that answers the user's request

## Table Structure Exploration:
- **Discovery/exploration queries**: Use `SELECT * LIMIT 1-5` to examine structure and sample values
- **Final answer queries**: Use `LIMIT 100000` or appropriate limits for the user's needs
- Use `SELECT DISTINCT "column" LIMIT 10` to explore available values in specific columns
- When exploring values, use small limits to understand data patterns, not retrieve results

## SQL Plan Query Rules:
- Never assume values exist: Only filter by values confirmed in previous SQL plan results.
- Explore first: Use `SELECT DISTINCT ... ILIKE '%pattern%'` to discover available values before filtering.
- Final step performs analysis: Last step in plan should perform the actual calculations/analysis requested.
- Progressive approach: Each step builds on previous results, with final step answering the user's question.

## Query Structure:
- Single table: Use directly
- Multiple tables: JOIN with proper value alignment (transform acronyms/dates as needed)
- Complex logic: Use CTEs only when multiple transformations required
- Data cleaning: Remove invalid values (-9999, empty strings, etc.)
- Date handling: Combine separate year/month/day columns if needed
- Plotting: Select extra columns for visualization flexibility
{%- endblock %}

{% block examples %}
Example queries:

**For discovery/exploration (small limits for understanding structure):**
```sql
-- Examine table structure and sample data
SELECT * FROM "table_name" LIMIT 2;
```

```sql
-- Explore available values in a column
SELECT DISTINCT "country_name"
FROM "table_name"
WHERE "country_name" IS NOT NULL
ORDER BY "country_name"
LIMIT 10;
```

**For final analysis (appropriate limits for user needs):**
```sql
-- Answer user's question with full results
SELECT "column_name", COUNT(*) AS "count"
FROM "table_name"
WHERE "text_column" = 'value'
  AND "category" IN ('option1', 'option2')
  AND "name" ILIKE '%pattern%'
GROUP BY "column_name"
ORDER BY "count" DESC
LIMIT 100000;
```
{% endblock %}

{% block context -%}
Additional instructions:
- Use only `{{ dialect }}` SQL dialect.
{%- if dialect == 'duckdb' %}
- If the table name originally did not have `read_*` prefix, use the original table name
- Use table names verbatim; e.g. if table is read_csv('table.csv') then use read_csv('table.csv') and not 'table' or 'table.csv'
- If `read_*` is used, use with alias, e.g. read_parquet('table.parq') as table_parq
- Use double quotes (") for column names and single quotes (') for ALL string literal values (e.g., ILIKE '%pattern%', 'text_value', '2023-01-01')
- Be sure to reference the full table slug, e.g. `source {{ separator }} table`
{% endif %}
{%- if dialect == 'snowflake' %}
- Do not under any circumstances add quotes around the database, schema or table name.
{% endif -%}

Step {{ step_number }} of SQL Plan: {{ current_step }}

{%- if previous_sql_plan_results is defined and previous_sql_plan_results %}
**Previous SQL Plan Results:**
{{ previous_sql_plan_results }}

**Based on previous SQL plan results:**
- Only filter by values that were confirmed to exist in the results above
- Build upon previous discoveries to answer the user's question
{%- else %}
**First SQL Plan Step:**
- Execute the current step as specified in the SQL plan
- If this is a discovery/exploration step: Use small LIMIT (5-10) to understand structure and values
- If this is the final answer step: Use appropriate LIMIT for user's needs (100000+ for full results)
{%- endif %}

{% if errors is defined and errors %}
{{ memory["sql_metaset"].full_context }}
{% else %}
{{ memory["sql_metaset"].table_context }}
{% endif %}
{%- endblock -%}

{%- block errors %}
{{ super() }}
{% if errors is defined and errors %}
**Common syntax error fixes:**
- If the error mentions `syntax error at or near "%"` or similar string patterns, you likely forgot to quote string literals with single quotes
- If the error is `syntax error at or near ")"`, double check you used table names verbatim, i.e. `read_parquet('table_name.parq')` instead of `table_name`
- Ensure no inline comments are present
- **Double-check that ALL string values are enclosed in single quotes ('')**

Here are some common fixes for errors:

- Handle NULL values using functions like COALESCE or IS NULL.
- If it's a date column (excluding individual year/month/day integers) date, cast to date using appropriate syntax, e.g.
CAST or TO_DATE
- Capture only the required numeric values while removing all whitespace, like `(\d+)`, or remove characters like `$`, `%`, `,`, etc, only if needed.
- Ensure robust type conversion using functions like TRY_CAST to avoid query failures due to invalid data.

Casting Examples:

If the query is "Which five regions have the highest total sales from 2022-02-22?"...

- GOOD:
```sql
WITH sales_summary AS (
    SELECT
        "region",
        SUM(
            TRY_CAST(
                REPLACE(
                    REPLACE("amount", '$', ''),
                    ',', ''
                ) AS DECIMAL(10,2)
            )
        ) AS total_sales
    FROM read_csv('sales.csv')
    WHERE "sale_date" >= DATE '2022-02-22'
      AND TRY_CAST(REPLACE(REPLACE("amount", '$', ''), ',', '') AS DECIMAL(10,2)) IS NOT NULL
      AND "region" IS NOT NULL
    GROUP BY "region"
)
SELECT
    "region",
    total_sales
FROM sales_summary
WHERE total_sales > 0
ORDER BY total_sales DESC
LIMIT 5;
```

- BAD:
```sql
SELECT region, SUM(amount) AS total_sales
FROM sales
WHERE sale_date >= '2022-02-22'
GROUP BY region
ORDER BY total_sales DESC;
```
{%- endif -%}
{% endblock -%}
